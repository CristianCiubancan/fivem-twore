#!/usr/bin/env node
// Load environment variables from .env file
import 'dotenv/config';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import chokidar from 'chokidar';
import { Command } from 'commander';
import { spawn } from 'node:child_process';
import {
  startHotReloadServer,
  getPluginDirs,
  validatePluginStructure,
} from '../core/index.ts';
// Compute the target resource directory under txData based on SERVER_NAME
const SERVER_NAME = process.env.SERVER_NAME ?? 'default';
/**
 * Get the output path for FiveM resources under txData/{SERVER_NAME}/resources/GENERATED
 * @param rootDir project root directory
 * @param subPaths additional path segments under GENERATED
 */
function getTxResourceDir(rootDir: string, ...subPaths: string[]): string {
  return path.join(
    rootDir,
    'txData',
    SERVER_NAME,
    'resources',
    '[GENERATED]',
    ...subPaths
  );
}
import { loadManifest } from '../core/manifest.ts';
import { copyDir, collectFiles, transpileTsFiles } from '../utils/fs.ts';
import type { PluginManifest } from '../core/manifest.ts';

const program = new Command();

program
  .name('fivem-twore')
  .description('CLI for FiveM Twore tooling')
  .version('0.0.0');

program
  .command('plugin:create')
  .description('Scaffold a new plugin')
  .argument('<namespace>', 'Plugin namespace')
  .argument('<name>', 'Plugin name')
  .action(async (namespace: string, name: string) => {
    const rootDir = process.cwd();
    const pluginsDir = path.join(rootDir, 'src', 'plugins');
    const nsDir = path.join(pluginsDir, namespace);
    const pluginDir = path.join(nsDir, name);
    // Check existence
    try {
      await fs.access(pluginDir);
      console.error(`Plugin directory already exists: ${pluginDir}`);
      process.exit(1);
    } catch {
      // proceed
    }
    // Create base directories
    await fs.mkdir(pluginDir, { recursive: true });
    const subdirs = ['client', 'server', 'translations', 'html', 'types'];
    for (const d of subdirs) {
      await fs.mkdir(path.join(pluginDir, d), { recursive: true });
    }
    // Create plugin.json
    const manifest = {
      name: `${namespace}:${name}`,
      version: '0.1.0',
      description: '',
      author: '',
      dependencies: [],
      exports: { client: [], server: [] },
      permissions: [],
    };
    const manifestPath = path.join(pluginDir, 'plugin.json');
    await fs.writeFile(
      manifestPath,
      JSON.stringify(manifest, null, 2) + '\n',
      'utf8'
    );
    // Create HTML entry
    const pageTsx = `export default function Page() {\n  return <div><h1>${namespace}/${name} UI</h1></div>;\n}\n`;
    await fs.writeFile(
      path.join(pluginDir, 'html', 'Page.tsx'),
      pageTsx,
      'utf8'
    );
    // Create .gitkeep in empty dirs
    for (const d of ['client', 'server', 'translations', 'types']) {
      await fs.writeFile(path.join(pluginDir, d, '.gitkeep'), '', 'utf8');
    }
    console.log(`Plugin scaffolded at ${pluginDir}`);
  });

program
  .command('webview:build')
  .description('Build combined webview NUI resource')
  .action(async () => {
    try {
      const rootDir = process.cwd();
      const pluginBase = path.join(rootDir, 'src', 'plugins');
      const pluginDirs = getPluginDirs(pluginBase);
      const pageInfos: {
        name: string;
        component: string;
        importPath: string;
      }[] = [];
      for (const dir of pluginDirs) {
        const rel = path.relative(pluginBase, dir).split(path.sep).join('/');
        const errors = validatePluginStructure(dir);
        if (errors.length > 0) {
          console.warn(`Skipping plugin ${rel} (invalid structure)`);
          continue;
        }
        const pageFile = path.join(dir, 'html', 'Page.tsx');
        if (
          await fs
            .stat(pageFile)
            .then((s) => s.isFile())
            .catch(() => false)
        ) {
          const compName = 'Page_' + rel.replace(/[^a-zA-Z0-9_]/g, '_');
          const importPath = './plugins/' + rel + '/html/Page.tsx';
          pageInfos.push({ name: rel, component: compName, importPath });
        }
      }
      if (pageInfos.length === 0) {
        console.warn('No plugin webview pages found to build.');
        return;
      }
      // Generate App.tsx
      const lines: string[] = [];
      lines.push(`// Auto-generated by cli: webview:build`);
      for (const info of pageInfos) {
        lines.push(
          `import ${info.component} from '${info.importPath.replace(
            './plugins/',
            '../plugins/'
          )}';`
        );
      }
      lines.push('');
      lines.push('const App = () => {');
      lines.push('  return (');
      lines.push('    <div>');
      for (const info of pageInfos) {
        lines.push(`      <div key="${info.name}"><${info.component} /></div>`);
      }
      lines.push('    </div>');
      lines.push('  );');
      lines.push('};');
      lines.push('');
      lines.push('export default App;');
      const appPath = path.join(rootDir, 'src', 'webview', 'App.tsx');
      await fs.writeFile(appPath, lines.join('\n') + '\n', 'utf8');
      console.log(
        `Generated webview App.tsx with ${pageInfos.length} plugin pages.`
      );
      // Build the webview bundle via Vite CLI
      console.log('Building webview via Vite (spawn)...');
      await new Promise<void>((resolve) => {
        const p = spawn('npx', ['vite', 'build', '--emptyOutDir'], {
          stdio: 'inherit',
          shell: true,
        });
        p.on('exit', (code: number) => {
          if (code !== 0) console.warn(`Vite build exited with code ${code}`);
          resolve();
        });
      });
      // Package the build output as a FiveM NUI resource
      console.log('Packaging webview as a FiveM NUI resource...');
      const webDist = path.join(rootDir, 'dist', 'web');
      // Output NUI resource under txData/{SERVER_NAME}/resources/GENERATED/webview
      const outDirResource = getTxResourceDir(rootDir, 'webview');
      await fs.rm(outDirResource, { recursive: true, force: true });
      await fs.mkdir(outDirResource, { recursive: true });
      // First, try copying build output
      await copyDir(webDist, outDirResource);
      let resourceFiles = await collectFiles(outDirResource, outDirResource);
      // Fallback: if no build output, copy development source
      if (resourceFiles.length === 0) {
        console.warn(
          'No webview build output found; copying dev source as fallback'
        );
        // Copy fallback index.html
        try {
          await fs.copyFile(
            path.join(rootDir, 'src', 'index.html'),
            path.join(outDirResource, 'index.html')
          );
        } catch {
          // ignore
        }
        // Copy webview sources
        await copyDir(path.join(rootDir, 'src', 'webview'), outDirResource);
        resourceFiles = await collectFiles(outDirResource, outDirResource);
      }
      // Generate fxmanifest.lua
      const manifestLines: string[] = [];
      manifestLines.push(`fx_version 'cerulean'`);
      manifestLines.push(`game 'gta5'`);
      manifestLines.push(`ui_page 'index.html'`);
      manifestLines.push(`files {`);
      for (const f of resourceFiles) manifestLines.push(`  '${f}',`);
      manifestLines.push(`}`);
      await fs.writeFile(
        path.join(outDirResource, 'fxmanifest.lua'),
        manifestLines.join('\n') + '\n',
        'utf8'
      );
      console.log(
        `Webview resource built: webview (${resourceFiles.length} files)`
      );
      // Clean up temporary Vite output
      await fs.rm(webDist, { recursive: true, force: true });
    } catch (err) {
      console.error('Error building webview:', (err as Error).message);
      process.exit(1);
    }
  });

// Build the core resource from src/core into txData/{SERVER_NAME}/resources/GENERATED/core
program
  .command('core:build')
  .description(
    'Compile core resource and bundle into txData/{SERVER_NAME}/resources/GENERATED/core'
  )
  .action(async () => {
    try {
      const rootDir = process.cwd();
      const coreSrc = path.join(rootDir, 'src', 'core');
      // Output core resource under txData/{SERVER_NAME}/resources/GENERATED/core
      const outDir = getTxResourceDir(rootDir, 'core');
      await fs.rm(outDir, { recursive: true, force: true });
      // Create the [GENERATED] directory if it doesn't exist
      await fs.mkdir(path.dirname(outDir), { recursive: true });
      // Copy core source files
      await copyDir(coreSrc, outDir);
      // Transpile TypeScript to JavaScript
      await transpileTsFiles(outDir);
      // Collect resource files
      const resourceFiles = await collectFiles(outDir, outDir);
      // Generate fxmanifest.lua
      const manifestLines: string[] = [];
      manifestLines.push(`fx_version 'cerulean'`);
      manifestLines.push(`game 'gta5'`);
      manifestLines.push(`server_scripts {`);
      for (const f of resourceFiles) manifestLines.push(`  '${f}',`);
      manifestLines.push(`}`);
      await fs.writeFile(
        path.join(outDir, 'fxmanifest.lua'),
        manifestLines.join('\n') + '\n',
        'utf8'
      );
      console.log(`Core resource built: core (${resourceFiles.length} files)`);
    } catch (err) {
      console.error('Error building core resource:', (err as Error).message);
      process.exit(1);
    }
  });

program
  .command('script:build')
  .description('Compile client/server scripts and bundle resources')
  .action(async () => {
    try {
      const rootDir = process.cwd();
      const pluginBase = path.join(rootDir, 'src', 'plugins');
      const pluginDirs = getPluginDirs(pluginBase);
      // Load and validate plugin manifests
      const plugins: Array<{ dir: string; manifest: PluginManifest }> = [];
      for (const dir_ of pluginDirs) {
        const rel = path.relative(pluginBase, dir_);
        const errors = validatePluginStructure(dir_);
        if (errors.length > 0) {
          console.warn(`Skipping plugin ${rel}:`);
          for (const e of errors) console.warn(`  - ${e}`);
        } else {
          const manifest = loadManifest(path.join(dir_, 'plugin.json'));
          plugins.push({ dir: dir_, manifest });
        }
      }
      if (plugins.length === 0) {
        console.error('No valid plugins to build');
        process.exit(1);
      }
      // Resolve dependencies and determine build order (topological sort)
      const nameMap = new Map<
        string,
        { dir: string; manifest: PluginManifest }
      >();
      for (const p of plugins) nameMap.set(p.manifest.name, p);
      const adj = new Map<string, string[]>();
      const indegree = new Map<string, number>();
      for (const p of plugins) {
        indegree.set(p.manifest.name, 0);
        adj.set(p.manifest.name, []);
      }
      for (const p of plugins) {
        const name = p.manifest.name;
        const deps = p.manifest.dependencies ?? [];
        for (const dep of deps) {
          if (!nameMap.has(dep)) {
            console.error(`Unknown dependency '${dep}' for plugin '${name}'`);
            process.exit(1);
          }
          adj.get(dep)!.push(name);
          indegree.set(name, (indegree.get(name) ?? 0) + 1);
        }
      }
      const queue: string[] = [];
      for (const [n, deg] of indegree) if (deg === 0) queue.push(n);
      const sortedPlugins: Array<{ dir: string; manifest: PluginManifest }> =
        [];
      while (queue.length > 0) {
        const cur = queue.shift()!;
        const p = nameMap.get(cur)!;
        sortedPlugins.push(p);
        for (const nxt of adj.get(cur)!) {
          indegree.set(nxt, (indegree.get(nxt) ?? 1) - 1);
          if (indegree.get(nxt) === 0) queue.push(nxt);
        }
      }
      if (sortedPlugins.length < plugins.length) {
        console.error('Circular plugin dependency detected');
        process.exit(1);
      }

      // Base directory for plugin resources under txData/{SERVER_NAME}/resources/GENERATED
      const distBase = getTxResourceDir(rootDir);
      // Ensure the resources directory exists
      await fs.mkdir(distBase, { recursive: true });

      // Build each plugin resource in dependency order
      for (const { dir, manifest } of sortedPlugins) {
        const resourceName = manifest.name.replace(/[:]/g, '_');
        const outDir = path.join(distBase, resourceName);
        await fs.rm(outDir, { recursive: true, force: true });
        // Copy script directories
        await copyDir(path.join(dir, 'client'), path.join(outDir, 'client'));
        await copyDir(path.join(dir, 'server'), path.join(outDir, 'server'));
        // Transpile TypeScript files
        await transpileTsFiles(path.join(outDir, 'client'));
        await transpileTsFiles(path.join(outDir, 'server'));
        // Collect script paths
        const clientFiles = await collectFiles(
          path.join(outDir, 'client'),
          outDir
        );
        const serverFiles = await collectFiles(
          path.join(outDir, 'server'),
          outDir
        );
        // Build fxmanifest.lua
        const lines: string[] = [];
        lines.push(`fx_version 'cerulean'`);
        lines.push(`game 'gta5'`);
        lines.push(`author '${manifest.author ?? ''}'`);
        lines.push(`description '${manifest.description ?? ''}'`);
        lines.push(`version '${manifest.version}'`);
        if (clientFiles.length) {
          lines.push(`client_scripts {`);
          for (const f of clientFiles) lines.push(`  '${f}',`);
          lines.push(`}`);
        }
        if (serverFiles.length) {
          lines.push(`server_scripts {`);
          for (const f of serverFiles) lines.push(`  '${f}',`);
          lines.push(`}`);
        }
        await fs.mkdir(outDir, { recursive: true });
        await fs.writeFile(
          path.join(outDir, 'fxmanifest.lua'),
          lines.join('\n') + '\n',
          'utf8'
        );
        console.log(`Built resource: ${resourceName}`);
      }
      console.log('All plugins built.');
    } catch (err) {
      console.error('Error building scripts:', (err as Error).message);
      process.exit(1);
    }
  });

program
  .command('dev')
  .description('Start development environment (hot-reload + webview)')
  .action(async () => {
    const rootDir = process.cwd();
    const pluginBase = path.join(rootDir, 'src', 'plugins');
    const runScript = (script: string) =>
      new Promise<void>((resolve, reject) => {
        const p = spawn('npm', ['run', script], {
          stdio: 'inherit',
          shell: true,
        });
        p.on('exit', (code: number) => {
          if (code === 0) resolve();
          else reject(new Error(`${script} exited with code ${code}`));
        });
      });
    try {
      // Create [GENERATED] directory if it doesn't exist
      const generatedDir = path.join(
        rootDir,
        'txData',
        SERVER_NAME,
        'resources',
        '[GENERATED]'
      );
      await fs.mkdir(generatedDir, { recursive: true });

      // Ensure server.cfg has "ensure GENERATED" above the "## Permissions ##" section
      const serverCfgPath = path.join(
        rootDir,
        'txData',
        SERVER_NAME,
        'server.cfg'
      );
      try {
        await fs.access(serverCfgPath);
        const content = await fs.readFile(serverCfgPath, 'utf8');
        const lines = content.split(/\r?\n/);
        const hasEnsure = lines.some((l) => l.trim() === 'ensure [GENERATED]');
        const permIdx = lines.findIndex((l) => l.includes('## Permissions'));
        if (!hasEnsure && permIdx !== -1) {
          lines.splice(permIdx, 0, 'ensure [GENERATED]');
          await fs.writeFile(serverCfgPath, lines.join('\n'), 'utf8');
          console.log(`Added "ensure [GENERATED]" to ${serverCfgPath}`);
        }
      } catch {
        // server.cfg not present or unreadable; skip
      }

      console.log('Running initial builds...');
      await runScript('core:build'); // Build the core resource first
      await runScript('webview:build');
      await runScript('script:build');
      console.log('Initial builds completed.');

      // Restart Docker containers to ensure they load the latest built resources
      console.log('Restarting Docker containers...');
      try {
        const dockerDown = spawn('docker-compose', ['down'], {
          stdio: 'inherit',
          shell: true,
        });
        await new Promise<void>((resolve, reject) => {
          dockerDown.on('exit', (code: number) => {
            if (code === 0) resolve();
            else
              reject(new Error(`docker-compose down exited with code ${code}`));
          });
        });

        const dockerUp = spawn('docker-compose', ['up', '--build', '-d'], {
          stdio: 'inherit',
          shell: true,
        });
        await new Promise<void>((resolve, reject) => {
          dockerUp.on('exit', (code: number) => {
            if (code === 0) resolve();
            else
              reject(new Error(`docker-compose up exited with code ${code}`));
          });
        });
        console.log('Docker containers restarted successfully.');
      } catch (err) {
        console.error('Docker restart failed:', err);
        process.exit(1);
      }
    } catch (err) {
      console.error('Initial build failed:', err);
      process.exit(1);
    }

    console.log('Starting hot-reload server...');
    // Optionally read a restart command from env var, e.g. FIVEM_RESTART_CMD="fivem-cli restart resource"
    const restartCmdEnv = process.env.FIVEM_RESTART_CMD;
    const restartCmd = restartCmdEnv ? restartCmdEnv.split(' ') : undefined;
    startHotReloadServer({ restartCommand: restartCmd });
    console.log('Watching plugin changes...');
    const debounceTime = 500;
    let webviewTimer: NodeJS.Timeout;
    let scriptTimer: NodeJS.Timeout;
    let coreTimer: NodeJS.Timeout;

    // Watch core files for rebuilds
    chokidar
      .watch(path.join(rootDir, 'src', 'core', '**/*'), { ignoreInitial: true })
      .on('all', (_event, changedPath) => {
        console.log(`Detected change in ${changedPath}, rebuilding core...`);
        clearTimeout(coreTimer);
        coreTimer = setTimeout(async () => {
          try {
            await runScript('core:build');
            console.log('Core rebuild completed.');
          } catch (err) {
            console.error('Core rebuild error:', err);
          }
        }, debounceTime);
      });

    // Watch HTML pages for webview rebuilds
    chokidar
      .watch(`${pluginBase}/**/html/Page.tsx`, { ignoreInitial: true })
      .on('all', (_event, changedPath) => {
        console.log(`Detected change in ${changedPath}, rebuilding webview...`);
        clearTimeout(webviewTimer);
        webviewTimer = setTimeout(async () => {
          try {
            await runScript('webview:build');
            console.log('Webview rebuild completed.');
          } catch (err) {
            console.error('Webview rebuild error:', err);
          }
        }, debounceTime);
      });
    // Watch client/server files for script rebuilds
    chokidar
      .watch(`${pluginBase}/**/{client,server}/**/*`, { ignoreInitial: true })
      .on('all', (_event, changedPath) => {
        console.log(`Detected change in ${changedPath}, rebuilding scripts...`);
        clearTimeout(scriptTimer);
        scriptTimer = setTimeout(async () => {
          try {
            await runScript('script:build');
            console.log('Scripts rebuild completed.');
          } catch (err) {
            console.error('Scripts rebuild error:', err);
          }
        }, debounceTime);
      });
    console.log('Launching Vite dev server...');
    const proc = spawn('npm', ['run', 'dev'], {
      stdio: 'inherit',
      shell: true,
    });
    proc.on('exit', (code: number) => process.exit(code ?? 0));
  });

// Fallback for unknown commands
program.on('command:*', ([cmd]) => {
  console.error(`Unknown command: ${cmd}`);
  program.help({ error: true });
});

// Execute commands (await ensures async actions finish before exit)
// Execute commands and catch errors; program.parseAsync returns a promise that resolves when actions complete
program.parseAsync(process.argv).catch((err) => {
  console.error(err);
  process.exit(1);
});
